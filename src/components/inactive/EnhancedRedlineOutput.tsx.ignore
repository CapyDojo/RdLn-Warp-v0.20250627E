/**
 * SSMR Phase 2: Enhanced RedlineOutput with Smart Rendering Strategy
 * 
 * This component enhances the existing RedlineOutput with intelligent rendering decisions
 * while preserving all existing functionality and maintaining backward compatibility.
 * 
 * SAFE: Preserves all existing RedlineOutput functionality 
 * MODULAR: Can be disabled by setting useEnhancedStrategy=false
 * REVERSIBLE: Falls back to original RedlineOutput behavior
 */

import React, { useMemo, useCallback, useRef, useEffect, useState } from 'react';
import { Copy } from 'lucide-react';
import { DiffChange } from '../../types';
import { 
  analyzeRenderingStrategy, 
  createSemanticChunks, 
  RenderingStrategy, 
  RenderingProgress,
  RENDERING_THRESHOLDS,
  RenderingDecision 
} from '../RenderingStrategy';

interface EnhancedRedlineOutputProps {
  changes: DiffChange[];
  onCopy: () => void;
  height?: number;
  originalText?: string;
  revisedText?: string;
  systemProtectionEnabled?: boolean; // System protection setting from main interface
  isProcessing?: boolean;            // Processing status for compatibility
  processingStatus?: string;         // Processing status message for compatibility
  
  // Enhancement controls (MODULAR - can be disabled)
  useEnhancedStrategy?: boolean;  // ROLLBACK: Set to false to use original behavior
  showRenderingInfo?: boolean;    // ROLLBACK: Set to false to hide strategy info
  showProgressIndicator?: boolean; // ROLLBACK: Set to false to hide progress
}

// Legacy virtual scrolling configuration (preserved for backward compatibility)
const LEGACY_VIRTUAL_THRESHOLD = 1000;
const LEGACY_CHUNK_SIZE = 500;
const LEGACY_CHUNK_HEIGHT = 400;
const LEGACY_BUFFER_CHUNKS = 1;

export const EnhancedRedlineOutput: React.FC<EnhancedRedlineOutputProps> = ({ 
  changes, 
  onCopy, 
  height = 500,
  originalText = '',
  revisedText = '',
  systemProtectionEnabled = true,  // Default enabled for safety
  isProcessing = false,            // Legacy compatibility
  processingStatus = 'Processing...', // Legacy compatibility
  useEnhancedStrategy = true,      // Ensure semantic chunking and paragraph breaks
  showRenderingInfo = false,       // Disable strategy info for standard behavior
  showProgressIndicator = false    // Disable progress indicators for standard behavior
}) => {
  // Rendering strategy state
  const [renderingDecision, setRenderingDecision] = useState<RenderingDecision | null>(null);
  const [currentStrategy, setCurrentStrategy] = useState<RenderingStrategy | null>(null);
  const [renderingProgress, setRenderingProgress] = useState({ progress: 0, stage: '' });
  const [isRendering, setIsRendering] = useState(false);
  
  // Virtual scrolling state (preserved from original)
  const [scrollTop, setScrollTop] = useState(0);
  const [containerHeight, setContainerHeight] = useState(height - 120);
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  
  // Determine rendering strategy when changes or enhanced strategy setting changes
  const strategy = useMemo(() => {
    if (!useEnhancedStrategy) {
      // FALLBACK: Use legacy virtual scrolling logic when enhanced strategy is disabled
      const useLegacyVirtual = changes.length > LEGACY_VIRTUAL_THRESHOLD;
      
      const legacyStrategy: RenderingStrategy = {
        mode: useLegacyVirtual ? 'virtual_scrolling' : 'immediate_static',
        state: 'complete',
        documentSize: 'medium', // Default
        diffComplexity: changes.length > 1000 ? 'complex' : 'simple',
        useVirtualScrolling: useLegacyVirtual,
        chunkSize: LEGACY_CHUNK_SIZE,
        showProgress: false,
        enableSemanticChunking: false
      };
      
      setCurrentStrategy(legacyStrategy);
      return legacyStrategy;
    }
    
    // Enhanced strategy analysis
    const decision = analyzeRenderingStrategy(originalText, revisedText, changes, systemProtectionEnabled);
    setRenderingDecision(decision);
    setCurrentStrategy(decision.strategy);
    
    console.log('🎯 Rendering strategy determined:', {
      mode: decision.strategy.mode,
      documentSize: decision.strategy.documentSize,
      diffComplexity: decision.strategy.diffComplexity,
      changeCount: changes.length,
      reasoning: decision.reasoning,
      estimatedTime: decision.estimatedRenderTime
    });
    
    return decision.strategy;
  }, [changes, originalText, revisedText, useEnhancedStrategy]);
  
  // Create semantic chunks if enabled
  const semanticChunks = useMemo(() => {
    if (!strategy?.enableSemanticChunking) {
      return [changes]; // Single chunk for non-semantic rendering
    }
    
    return createSemanticChunks(changes, strategy.chunkSize);
  }, [changes, strategy?.enableSemanticChunking, strategy?.chunkSize]);
  
  // Virtual scrolling calculations (preserved from original with enhancements)
  const virtualScrollingConfig = useMemo(() => {
    if (!strategy?.useVirtualScrolling) {
      return {
        visibleChunks: semanticChunks,
        totalHeight: 0,
        startChunkIndex: 0
      };
    }
    
    // Use semantic chunks for virtual scrolling if available
    const chunksToUse = strategy.enableSemanticChunking ? semanticChunks : [changes];
    const chunkHeight = RENDERING_THRESHOLDS.VIRTUAL_CHUNK_HEIGHT;
    const bufferChunks = RENDERING_THRESHOLDS.VIRTUAL_BUFFER_CHUNKS;
    
    const totalChunks = chunksToUse.length;
    const startChunk = Math.floor(scrollTop / chunkHeight);
    const visibleChunkCount = Math.ceil(containerHeight / chunkHeight) + bufferChunks * 2;
    const startWithBuffer = Math.max(0, startChunk - bufferChunks);
    const endWithBuffer = Math.min(totalChunks - 1, startChunk + visibleChunkCount);
    
    const visibleChunks = chunksToUse.slice(startWithBuffer, endWithBuffer + 1);
    
    return {
      visibleChunks,
      totalHeight: totalChunks * chunkHeight,
      startChunkIndex: startWithBuffer
    };
  }, [semanticChunks, changes, strategy, scrollTop, containerHeight]);
  
  // Progressive rendering simulation for demo purposes
  useEffect(() => {
    if (!strategy?.showProgress || strategy.state === 'complete') {
      return;
    }
    
    setIsRendering(true);
    setRenderingProgress({ progress: 0, stage: 'Initializing...' });
    
    // Simulate progressive rendering stages
    const stages = [
      { progress: 20, stage: 'Analyzing document structure...', delay: 100 },
      { progress: 50, stage: 'Processing semantic chunks...', delay: 200 },
      { progress: 80, stage: 'Optimizing for display...', delay: 150 },
      { progress: 100, stage: 'Rendering complete', delay: 100 }
    ];
    
    let currentStage = 0;
    const runNextStage = () => {
      if (currentStage < stages.length) {
        const stage = stages[currentStage];
        setTimeout(() => {
          setRenderingProgress({ progress: stage.progress, stage: stage.stage });
          
          if (stage.progress === 100) {
            setIsRendering(false);
            if (currentStrategy) {
              setCurrentStrategy(prev => prev ? { ...prev, state: 'complete' } : null);
            }
          }
          
          currentStage++;
          runNextStage();
        }, stage.delay);
      }
    };
    
    runNextStage();
  }, [strategy?.showProgress, strategy?.state, changes.length]);
  
  // Throttled scroll handler (preserved from original)
  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    const newScrollTop = e.currentTarget.scrollTop;
    const chunkHeight = strategy?.useVirtualScrolling 
      ? RENDERING_THRESHOLDS.VIRTUAL_CHUNK_HEIGHT 
      : LEGACY_CHUNK_HEIGHT;
      
    if (Math.abs(newScrollTop - scrollTop) > chunkHeight / 4) {
      setScrollTop(newScrollTop);
    }
  }, [scrollTop, strategy?.useVirtualScrolling]);
  
  // Update container height when component resizes (preserved from original)
  useEffect(() => {
    setContainerHeight(height - 120);
  }, [height]);
  
  // Performance monitoring (enhanced)
  useEffect(() => {
    if (!strategy) return;
    
    const totalVisibleItems = virtualScrollingConfig.visibleChunks.reduce(
      (sum, chunk) => sum + (Array.isArray(chunk) ? chunk.length : 1), 
      0
    );
    
    console.log('🖼️ Enhanced rendering viewport:', {
      mode: strategy.mode,
      virtualScrolling: strategy.useVirtualScrolling,
      semanticChunking: strategy.enableSemanticChunking,
      visibleChunks: virtualScrollingConfig.visibleChunks.length,
      visibleItems: totalVisibleItems,
      totalChanges: changes.length
    });
  }, [virtualScrollingConfig, strategy, changes.length]);
  
  // Render individual change (preserved from original)
  const renderChange = useCallback((change: DiffChange, originalIndex: number) => {
    const key = `${change.type}-${originalIndex}`;
    
    switch (change.type) {
      case 'added':
        return (
          <span key={key} className="bg-theme-secondary-100 text-theme-secondary-800 underline decoration-2 decoration-theme-secondary-600" style={{ whiteSpace: 'pre-wrap' }}>
            {change.content}
          </span>
        );
      case 'removed':
        return (
          <span key={key} className="bg-theme-accent-100 text-theme-accent-800 line-through decoration-2 decoration-theme-accent-600" style={{ whiteSpace: 'pre-wrap' }}>
            {change.content}
          </span>
        );
      case 'changed':
        return (
          <span key={key}>
            <span className="bg-theme-accent-100 text-theme-accent-800 line-through decoration-2 decoration-theme-accent-600" style={{ whiteSpace: 'pre-wrap' }}>
              {change.originalContent}
            </span>
            <span className="bg-theme-secondary-100 text-theme-secondary-800 underline decoration-2 decoration-theme-secondary-600" style={{ whiteSpace: 'pre-wrap' }}>
              {change.revisedContent}
            </span>
          </span>
        );
      case 'unchanged':
        return (
          <span key={key} className="text-theme-neutral-800" style={{ whiteSpace: 'pre-wrap' }}>
            {change.content}
          </span>
        );
      default:
        return null;
    }
  }, []);
  
  // Copy functionality (preserved from original)
  const copyToClipboard = async () => {
    const text = changes.map(change => {
      switch (change.type) {
        case 'changed':
          return change.revisedContent || '';
        case 'removed':
          return ''; // Don't include removed content in final text
        default:
          return change.content;
      }
    }).join('');
    
    try {
      await navigator.clipboard.writeText(text);
      onCopy();
    } catch (err) {
      console.error('Failed to copy text:', err);
    }
  };
  
  // Render semantic chunk
  const renderSemanticChunk = useCallback((chunk: DiffChange[], chunkIndex: number, startIndex: number = 0) => {
    const chunkHeight = strategy?.useVirtualScrolling ? RENDERING_THRESHOLDS.VIRTUAL_CHUNK_HEIGHT : undefined;
    
    return (
      <div 
        key={`semantic-chunk-${chunkIndex}`} 
        style={chunkHeight ? { minHeight: chunkHeight } : undefined}
className="chunk-container"
      >
        {chunk.map((change, itemIndex) => {
          const originalIndex = startIndex + itemIndex;
          return renderChange(change, originalIndex);
        })}
      </div>
    );
  }, [strategy?.useVirtualScrolling, renderChange]);
  
  // Render content based on strategy
  const renderContent = () => {
    if (!strategy) {
      return <div>Loading...</div>;
    }
    
    // Emergency fallback mode
    if (strategy.mode === 'emergency_fallback') {
      return (
        <div className="p-6 text-center">
          <div className="text-theme-accent-600 font-medium mb-2">
            ⚠️ Large change set detected
          </div>
          <div className="text-sm text-theme-neutral-600 mb-4">
            {changes.length.toLocaleString()} changes found. This may impact performance.
          </div>
          <div className="text-xs text-theme-neutral-500">
            Consider comparing smaller document sections or use the original comparison approach.
          </div>
        </div>
      );
    }
    
    // Virtual scrolling mode
    if (strategy.useVirtualScrolling) {
      const { visibleChunks, totalHeight, startChunkIndex } = virtualScrollingConfig;
      const chunkHeight = RENDERING_THRESHOLDS.VIRTUAL_CHUNK_HEIGHT;
      
      return (
        <div style={{ height: totalHeight, position: 'relative' }}>
          <div 
            style={{ 
              transform: `translateY(${startChunkIndex * chunkHeight}px)`,
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0
            }}
          >
            <div className="font-serif text-theme-neutral-800 leading-relaxed whitespace-pre-wrap libertinus-math-output">
              {visibleChunks.map((chunk, chunkIndex) => {
                const actualChunkIndex = startChunkIndex + chunkIndex;
                const startIndex = strategy.enableSemanticChunking 
                  ? semanticChunks.slice(0, actualChunkIndex).reduce((sum, c) => sum + c.length, 0)
                  : actualChunkIndex * strategy.chunkSize;
                
                if (Array.isArray(chunk)) {
                  return renderSemanticChunk(chunk, actualChunkIndex, startIndex);
                } else {
                  // Handle legacy single changes
                  return renderChange(chunk as DiffChange, actualChunkIndex);
                }
              })}
            </div>
          </div>
        </div>
      );
    }
    
    // Static rendering (immediate, progressive, or stream modes)
    return (
      <div className="font-serif text-theme-neutral-800 leading-relaxed whitespace-pre-wrap libertinus-math-output">
        {strategy.enableSemanticChunking ? (
          // Render semantic chunks
          semanticChunks.map((chunk, chunkIndex) => {
            const startIndex = semanticChunks.slice(0, chunkIndex).reduce((sum, c) => sum + c.length, 0);
            return renderSemanticChunk(chunk, chunkIndex, startIndex);
          })
        ) : (
          // Render all changes directly
          changes.map((change, index) => renderChange(change, index))
        )}
        
        {/* Legacy processing status display (preserved from original RedlineOutput) */}
        {isProcessing && (
          <div className="mt-4 p-3 bg-theme-primary-50 border border-theme-primary-200 rounded-lg">
            <div className="flex items-center gap-2 text-theme-primary-700">
              <div className="w-4 h-4 border-2 border-theme-primary-400 border-t-transparent rounded-full animate-spin"></div>
              <span className="text-sm font-medium">{processingStatus}</span>
            </div>
          </div>
        )}
      </div>
    );
  };
  
  return (
    <div className="glass-panel overflow-hidden shadow-lg transition-all duration-300">
      {/* Header */}
      <div className="glass-panel-header-footer px-4 py-3 border-b border-theme-neutral-200 flex items-center justify-between">
        <h3 className="text-lg font-semibold text-theme-primary-900">
          Compared Redline
        </h3>
        <div className="flex gap-2">
          <button
            onClick={copyToClipboard}
            className="enhanced-button flex items-center gap-2 px-3 py-1.5 text-sm bg-theme-primary-600 text-white rounded hover:bg-theme-primary-700 transition-all duration-200 shadow-lg"
          >
            <Copy className="w-4 h-4" />
            Copy
          </button>
        </div>
      </div>
      
      {/* Enhanced Strategy Info (MODULAR - can be hidden) */}
      {showRenderingInfo && renderingDecision && currentStrategy && (
        <div className="px-4 py-2 bg-theme-neutral-50 border-b border-theme-neutral-200">
          <div className="flex items-center justify-between text-xs">
            <div className="text-theme-neutral-600">
              <span className="font-medium">{currentStrategy.mode.replace('_', ' ')}</span>
              {' • '}
              {currentStrategy.documentSize} doc, {currentStrategy.diffComplexity} changes
              {currentStrategy.useVirtualScrolling && ' • virtual scrolling'}
              {currentStrategy.enableSemanticChunking && ' • semantic chunks'}
            </div>
            <div className="text-theme-neutral-500">
              ~{renderingDecision.estimatedRenderTime}ms
            </div>
          </div>
          {renderingDecision.recommendations.length > 0 && (
            <div className="text-xs text-theme-secondary-600 mt-1">
              {renderingDecision.recommendations[0]}
            </div>
          )}
        </div>
      )}
      
      {/* Progress Indicator (MODULAR - can be hidden) */}
      {showProgressIndicator && currentStrategy && (
        <RenderingProgress
          strategy={currentStrategy}
          progress={renderingProgress.progress}
          stage={renderingProgress.stage}
          enabled={isRendering}
          className="mx-4 mt-3"
        />
      )}
      
      {/* Content */}
      <div 
        ref={scrollContainerRef}
        className="glass-panel-inner-content p-6 overflow-y-auto" 
        style={{ height: `${height - 120}px`, minHeight: '200px' }}
        onScroll={strategy?.useVirtualScrolling ? handleScroll : undefined}
      >
        {renderContent()}
      </div>
      
      {/* Footer */}
      <div className="glass-panel-header-footer px-4 py-2 border-t border-theme-neutral-200 text-xs text-theme-neutral-600">
        <div className="flex justify-between items-center">
          <div className="flex gap-6">
            <span className="flex items-center gap-1">
              <span className="w-3 h-3 bg-theme-secondary-100 border border-theme-secondary-300 rounded"></span>
              Additions
            </span>
            <span className="flex items-center gap-1">
              <span className="w-3 h-3 bg-theme-accent-100 border border-theme-accent-300 rounded"></span>
              Deletions
            </span>
            <span className="flex items-center gap-1">
              <span className="w-3 h-3 bg-theme-accent-100 border border-theme-accent-300 rounded"></span>
              Changes (substitutions)
            </span>
          </div>
          
          {strategy?.useVirtualScrolling && (
            <div className="text-theme-neutral-500">
              Virtual scrolling: {virtualScrollingConfig.visibleChunks.reduce(
                (sum, chunk) => sum + (Array.isArray(chunk) ? chunk.length : 1), 
                0
              )} of {changes.length} visible
            </div>
          )}
          
          {showRenderingInfo && currentStrategy && (
            <div className="text-theme-neutral-500">
              {changes.length.toLocaleString()} changes • {currentStrategy.mode}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default EnhancedRedlineOutput;
